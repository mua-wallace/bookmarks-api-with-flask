<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="updatedContent" value="# Byte-compiled / optimized / DLL files&#10;__pycache__/&#10;*.py[cod]&#10;*$py.class&#10;&#10;# C extensions&#10;*.so&#10;&#10;# Distribution / packaging&#10;.Python&#10;build/&#10;develop-eggs/&#10;dist/&#10;downloads/&#10;eggs/&#10;.eggs/&#10;lib/&#10;lib64/&#10;parts/&#10;sdist/&#10;var/&#10;wheels/&#10;pip-wheel-metadata/&#10;share/python-wheels/&#10;*.egg-info/&#10;.installed.cfg&#10;*.egg&#10;MANIFEST&#10;&#10;# Virtual environments&#10;.env&#10;.venv&#10;env/&#10;venv/&#10;ENV/&#10;env.bak/&#10;venv.bak/&#10;&#10;# PyInstaller&#10;*.manifest&#10;*.spec&#10;&#10;# Installer logs&#10;pip-log.txt&#10;pip-delete-this-directory.txt&#10;&#10;# Unit test / coverage reports&#10;htmlcov/&#10;.tox/&#10;.nox/&#10;.coverage&#10;.coverage.*&#10;.cache&#10;nosetests.xml&#10;coverage.xml&#10;*.cover&#10;.hypothesis/&#10;.pytest_cache/&#10;&#10;# Translations&#10;*.mo&#10;*.pot&#10;&#10;# Django stuff:&#10;*.log&#10;local_settings.py&#10;db.sqlite3&#10;&#10;# Flask stuff:&#10;instance/&#10;.webassets-cache&#10;&#10;# Scrapy stuff:&#10;.scrapy&#10;&#10;# Sphinx documentation&#10;docs/_build/&#10;&#10;# PyBuilder&#10;target/&#10;&#10;# Jupyter Notebook&#10;.ipynb_checkpoints&#10;&#10;# IPython&#10;profile_default/&#10;ipython_config.py&#10;&#10;# pyenv&#10;.python-version&#10;&#10;# celery beat schedule file&#10;celerybeat-schedule&#10;&#10;# dotenv&#10;.env.*&#10;*.env&#10;&#10;# mypy&#10;.mypy_cache/&#10;.dmypy.json&#10;dmypy.json&#10;&#10;# Pyre type checker&#10;.pyre/&#10;&#10;# VS Code&#10;.vscode/&#10;&#10;# PyCharm&#10;.idea/&#10;&#10;# Mac&#10;.DS_Store&#10;&#10;# System&#10;Thumbs.db&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/auth.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/auth.py" />
              <option name="originalContent" value="from flask import Blueprint, request, jsonify, current_app&#10;from werkzeug.security import generate_password_hash, check_password_hash&#10;import validators&#10;from flask_jwt_extended import create_refresh_token, create_access_token, jwt_required, get_jwt_identity&#10;import datetime&#10;&#10;from src.constants.http_status_code import (&#10;    HTTP_400_BAD_REQUEST,&#10;    HTTP_201_CREATED,&#10;    HTTP_409_CONFLICT,&#10;    HTTP_200_OK,&#10;    HTTP_401_UNAUTHORIZED&#10;)&#10;from src.database import User, db&#10;&#10;auth = Blueprint('auth', __name__, url_prefix='/api/v1/auth')&#10;&#10;@auth.route('/login', methods=['POST'])&#10;def login():&#10;    # Ensure JWT_REFRESH_TOKEN_EXPIRES is set as a timedelta inside the app context&#10;    if 'JWT_REFRESH_TOKEN_EXPIRES' not in current_app.config or not isinstance(current_app.config['JWT_REFRESH_TOKEN_EXPIRES'], datetime.timedelta):&#10;        current_app.config['JWT_REFRESH_TOKEN_EXPIRES'] = datetime.timedelta(days=30)&#10;&#10;    email = request.json.get('email')&#10;    password = request.json.get('password')&#10;&#10;    user = User.query.filter(User.email == email).first()&#10;    if user:&#10;        if check_password_hash(user.password, password):&#10;            refresh_token = create_refresh_token(identity=str(user.id))&#10;            access_token = create_access_token(identity=str(user.id))&#10;            return jsonify({&quot;message&quot;: &quot;Login successful&quot;,&#10;                            &quot;user&quot;: {&#10;                                &quot;username&quot;: user.username,&#10;                                &quot;email&quot;: user.email,&#10;                                &quot;access_token&quot;: access_token,&#10;                                &quot;refresh_token&quot;: refresh_token&#10;                            },&#10;                            }), HTTP_200_OK&#10;        else:&#10;            return jsonify({&quot;error&quot;: &quot;Invalid credentials&quot;}), HTTP_401_UNAUTHORIZED&#10;    else:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid credentials&quot;}), HTTP_401_UNAUTHORIZED&#10;&#10;@auth.route('/register', methods=['POST'])&#10;def register():&#10;    username = request.json.get('username')&#10;    password = request.json.get('password')&#10;    email = request.json.get('email')&#10;&#10;    if not username or not password or not email:&#10;        return jsonify({&quot;error&quot;: &quot;Username, password, and email are required&quot;}), HTTP_400_BAD_REQUEST&#10;&#10;    if len(password) &lt; 8:&#10;        return jsonify({&quot;error&quot;: &quot;Password must be at least 8 characters long&quot;}), HTTP_400_BAD_REQUEST&#10;    if len(username) &lt; 3:&#10;        return jsonify({&quot;error&quot;: &quot;Username must be at least 3 characters long&quot;}), HTTP_400_BAD_REQUEST&#10;    if not username.isalnum():&#10;        return jsonify({&quot;error&quot;: &quot;Username must be alphanumeric and cannot contain spaces&quot;}), HTTP_400_BAD_REQUEST&#10;    if not validators.email(email):&#10;        return jsonify({&quot;error&quot;: &quot;Invalid email address&quot;}), HTTP_400_BAD_REQUEST&#10;    if User.query.filter(User.email == email).first():&#10;        return jsonify({&quot;error&quot;: &quot;Email is taken&quot;}), HTTP_409_CONFLICT&#10;    if User.query.filter(User.username == username).first():&#10;        return jsonify({&quot;error&quot;: &quot;Username is taken&quot;}), HTTP_409_CONFLICT&#10;    hashed_password = generate_password_hash(password)&#10;    user = User(username=username, password=hashed_password, email=email)&#10;    db.session.add(user)&#10;    db.session.commit()&#10;    return jsonify({&quot;message&quot;: &quot;User registered successfully&quot;, &quot;user&quot;: {&#10;        &quot;username&quot;: user.username,&#10;        &quot;email&quot;: user.email,&#10;    }}), HTTP_201_CREATED&#10;&#10;@auth.route('/logout', methods=['POST'])&#10;def logout():&#10;    return jsonify({&quot;message&quot;: &quot;Logout successful&quot;}), HTTP_200_OK&#10;&#10;@auth.route('/me', methods=['GET'])&#10;@jwt_required()&#10;def me():&#10;    user_id = get_jwt_identity()&#10;    user = User.query.filter_by(id=int(user_id)).first()&#10;    if not user:&#10;        return jsonify({&quot;error&quot;: &quot;User not found&quot;}), HTTP_401_UNAUTHORIZED&#10;    user_data = {&#10;        &quot;id&quot;: user.id,&#10;        &quot;username&quot;: user.username,&#10;        &quot;email&quot;: user.email,&#10;    }&#10;    return jsonify(user_data), HTTP_200_OK&#10;&#10;&#10;@auth.route('/refresh', methods=['POST'])&#10;@jwt_required(refresh=True)&#10;def refresh():&#10;    user_id = get_jwt_identity()&#10;    access_token = create_access_token(identity=str(user_id))&#10;    return jsonify({&quot;access_token&quot;: access_token}), HTTP_200_OK&#10;" />
              <option name="updatedContent" value="from flask import Blueprint, request, jsonify, current_app&#10;from werkzeug.security import generate_password_hash, check_password_hash&#10;import validators&#10;from flask_jwt_extended import create_refresh_token, create_access_token, jwt_required, get_jwt_identity&#10;import datetime&#10;&#10;from src.constants.http_status_code import (&#10;    HTTP_400_BAD_REQUEST,&#10;    HTTP_201_CREATED,&#10;    HTTP_409_CONFLICT,&#10;    HTTP_200_OK,&#10;    HTTP_401_UNAUTHORIZED&#10;)&#10;from src.database import User, db&#10;&#10;auth = Blueprint('auth', __name__, url_prefix='/api/v1/auth')&#10;&#10;@auth.route('/login', methods=['POST'])&#10;def login():&#10;    # Ensure JWT_SECRET_KEY is set&#10;    if 'JWT_SECRET_KEY' not in current_app.config or not current_app.config['JWT_SECRET_KEY']:&#10;        return jsonify({&quot;error&quot;: &quot;JWT_SECRET_KEY is not set in app config&quot;}), HTTP_401_UNAUTHORIZED&#10;&#10;    # Ensure JWT_REFRESH_TOKEN_EXPIRES is set as a timedelta inside the app context&#10;    if 'JWT_REFRESH_TOKEN_EXPIRES' not in current_app.config or not isinstance(current_app.config['JWT_REFRESH_TOKEN_EXPIRES'], datetime.timedelta):&#10;        current_app.config['JWT_REFRESH_TOKEN_EXPIRES'] = datetime.timedelta(days=30)&#10;&#10;    data = request.get_json()&#10;    identifier = data.get('identifier')  # can be email or username&#10;    password = data.get('password')&#10;&#10;    if not identifier or not password:&#10;        return jsonify({&quot;error&quot;: &quot;Identifier and password are required&quot;}), HTTP_400_BAD_REQUEST&#10;&#10;    user = User.query.filter(&#10;        (User.email == identifier) | (User.username == identifier)&#10;    ).first()&#10;&#10;    if user and check_password_hash(user.password, password):&#10;        refresh_token = create_refresh_token(identity=str(user.id))&#10;        access_token = create_access_token(identity=str(user.id))&#10;        return jsonify({&#10;            &quot;message&quot;: &quot;Login successful&quot;,&#10;            &quot;user&quot;: {&#10;                &quot;username&quot;: user.username,&#10;                &quot;email&quot;: user.email,&#10;                &quot;access_token&quot;: access_token,&#10;                &quot;refresh_token&quot;: refresh_token&#10;            },&#10;        }), HTTP_200_OK&#10;    else:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid credentials&quot;}), HTTP_401_UNAUTHORIZED&#10;&#10;@auth.route('/register', methods=['POST'])&#10;def register():&#10;    username = request.json.get('username')&#10;    password = request.json.get('password')&#10;    email = request.json.get('email')&#10;&#10;    if not username or not password or not email:&#10;        return jsonify({&quot;error&quot;: &quot;Username, password, and email are required&quot;}), HTTP_400_BAD_REQUEST&#10;&#10;    if len(password) &lt; 8:&#10;        return jsonify({&quot;error&quot;: &quot;Password must be at least 8 characters long&quot;}), HTTP_400_BAD_REQUEST&#10;    if len(username) &lt; 3:&#10;        return jsonify({&quot;error&quot;: &quot;Username must be at least 3 characters long&quot;}), HTTP_400_BAD_REQUEST&#10;    if not username.isalnum():&#10;        return jsonify({&quot;error&quot;: &quot;Username must be alphanumeric and cannot contain spaces&quot;}), HTTP_400_BAD_REQUEST&#10;    if not validators.email(email):&#10;        return jsonify({&quot;error&quot;: &quot;Invalid email address&quot;}), HTTP_400_BAD_REQUEST&#10;    if User.query.filter(User.email == email).first():&#10;        return jsonify({&quot;error&quot;: &quot;Email is taken&quot;}), HTTP_409_CONFLICT&#10;    if User.query.filter(User.username == username).first():&#10;        return jsonify({&quot;error&quot;: &quot;Username is taken&quot;}), HTTP_409_CONFLICT&#10;    hashed_password = generate_password_hash(password)&#10;    user = User(username=username, password=hashed_password, email=email)&#10;    db.session.add(user)&#10;    db.session.commit()&#10;    return jsonify({&quot;message&quot;: &quot;User registered successfully&quot;, &quot;user&quot;: {&#10;        &quot;username&quot;: user.username,&#10;        &quot;email&quot;: user.email,&#10;    }}), HTTP_201_CREATED&#10;&#10;@auth.route('/logout', methods=['POST'])&#10;def logout():&#10;    return jsonify({&quot;message&quot;: &quot;Logout successful&quot;}), HTTP_200_OK&#10;&#10;@auth.route('/me', methods=['GET'])&#10;@jwt_required()&#10;def me():&#10;    user_id = get_jwt_identity()&#10;    user = User.query.filter_by(id=int(user_id)).first()&#10;    if not user:&#10;        return jsonify({&quot;error&quot;: &quot;User not found&quot;}), HTTP_401_UNAUTHORIZED&#10;    user_data = {&#10;        &quot;id&quot;: user.id,&#10;        &quot;username&quot;: user.username,&#10;        &quot;email&quot;: user.email,&#10;    }&#10;    return jsonify(user_data), HTTP_200_OK&#10;&#10;&#10;@auth.route('/refresh', methods=['POST'])&#10;@jwt_required(refresh=True)&#10;def refresh():&#10;    user_id = get_jwt_identity()&#10;    access_token = create_access_token(identity=str(user_id))&#10;    return jsonify({&quot;access_token&quot;: access_token}), HTTP_200_OK" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>